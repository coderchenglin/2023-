#include<iostream>

using namespace std;


//一.引用
//void TestRef()
//{
//	int a = 10;
//	int& ra = a;
//
//	printf("%p\n", &a);    // 0033FABC
//	printf("%p\n", &ra);    // 0033FABC
//}
//
//int main()
//{
//	TestRef(); 
//
//	return 0;
//}

//引用总结:
//1.一个变量可以有多个引用
//2.引用必须在定义时就初始化
//3.引用一旦引用了某个实体,是不能修改的(即再不能引用其他实体)

//这就是为什么引用不能完全替代指针的原因,因为不能改变引用的指向
//指针的可以先指向一个结点,后面可以改变,指向另一个结点的.但引用不行


//int main()
//{
//	int  a = 10;
//	int& ra = a;   //ra是a的引用
//
//	int b = 20;
//	ra = b;   //这里是赋值,不是改变ra的引用对象
//
//	return 0;
//}


//引用的作用
//1.做参数      --     输出型参数
//   如:Swap函数

//2.引用做返回值
//传值返回:会产生一个临时变量来接收返回值,再把这个临时变量拷贝给接收的返回值的变量
//传引用返回:直接返回这个变量.
//所以如果当函数栈帧销毁了,这个变量还在,那么就可以使用传引用返回,如果不再,就不能使用传引用返回(相当于越界访问了)


//传值返回:正确:
//int count()
//{
//	int n = 0;
//	n++;
//
//	return n;   //传一个临时变量回去,这个临时变量不是存在栈帧中的,通常存在寄存器中
//}

//传引用返回:错误
//int& count()
//{
//	int n = 0;    //函数栈帧销毁时,变量也销毁了
//	n++;
//
//	return n;
//}

////传引用返回:正确
//int& count()
//{
//	static int n = 0;   //函数栈帧销毁时,变量还在
//	n++;
//
//	return n;   //也可以认为是产生了一个临时变量,但是这个临时变量是n的别名,不另开空间,相当于就返回了n变量本身
//}
//
//int main()
//{
//	int ret = count();
//	cout << ret << endl;  // 1
//
//	return 0;
//}



//以下是一段错误的程序 :  
//int& count()
//{
//	int n = 0;
//	n++;
//	return n;
//}
//
//void Func()
//{
//	int x = 100;
//}
//
//int main()
//{
//	int& ret = count();
//	cout << ret << endl;
//	cout << ret << endl;
//	Func();
//	Func();
//	cout << ret << endl;
//	cout << ret << endl;
//}


//结论:出了函数作用域,返回变量不存在了,不能用引用返回,因为引用返回的结果是未定义的.
//		出了函数作用域,返回变量存在,才能用引用返回

//反正这个变量不能再栈上,在静态区,在堆上,都行,出了函数作用域,这个变量都还是存在的 


//传引用返回相比于传值返回的好处: 
//1.减少拷贝,提高效率
//2. 修改返回值

//引用做参数的好处:
//1.减少拷贝,提高效率
//2.做输出型参数,函数中修改形参,实参也修改了


//引用的权限放大与缩小  --- 权限只有在使用引用和指针的情况,才需要考虑.普通的参数不存在权限问题

//int main()
//{
//	int a = 0;
//	//权限不变
//	int& ra = a;
//
//	//指针和引用赋值中,权限可以缩小,不能放大
//	const int b = 1;
//
//	//权限放大 -- 错误
//	//int& rb = b;
//
//	//权限缩小 -- 正确
//	const int& rra = a;
//
//	//权限平移 -- 正确
//	const int& rb = b;
//
//
//	return 0;
//}


//重点:const引用
//一般用引用做参数都是const引用   --   因为只可能是权限的平移或权限的缩小

//int a = 0;
//void func(int& N = 10)  //报错,非常量引用必须为左值
//{
//	cout << N << endl;
//}
//void func(int& N = a)    //正确
//{
//	cout << N << endl;
//}
//void func(const int& N = 10)  //正确,const常量引用可以有默认值,因为const引用可以指向任何对象包括临时对象和常量对象
//{
//	cout << N << endl;
//}
//
////解释:
////普通引用做函数参数不能有默认值的原因是因为普通引用必须始终绑定到某个对象。如果将一个未初始化的普通引用传递给函数，则可能会导致不可预测的行为或程序崩溃。因此，将普通引用设置为默认参数值是不安全的，因为当调用函数时省略参数时，将使用该默认值，但由于引用未绑定到任何对象，因此会导致错误。
////
////另一方面，const引用做函数参数的默认值是安全的，因为const引用可以指向任何类型的对象，包括临时对象和常量对象。在函数调用时，如果省略了该参数，则将使用默认值，它将被视为指向一个临时对象或常量对象的const引用。因为临时对象和常量对象在函数执行期间不会被修改，所以const引用参数的默认值是安全的。
////
////因此，为了确保函数的安全性和可靠性，普通引用做函数参数时不能有默认值，只有const引用做函数参数时才能有默认值。
//
//int main()
//{
//	func();
//}


//int count()
//{
//	int n = 0;
//
//	return n;
//}
//
//int main()
//{
//	const int& b = 10; 
//
//	double d = 12.34;
//
//	cout << (int)d << endl;   //12
//
//	int i = d; // 可以  ---   类型转换
//	              //d会首先产生一个int类型的临时变量,在把这个临时变量赋值给i
//	cout << i << endl;   //12
//
//	//类型转换不能使用普通引用
//	//int& ri = d;  //报错   ---  涉及到这种类型转换,会产生临时变量,临时变量具有常性,需要用const引用,不能用普通引用
//	const int& ri = d;
//
//	//传值返回也不能使用引用接收 ---  传值返回会产生临时变量,而临时变量具有常性
//	//int& ret = count(); //报错  -- 非常量引用的
//	const int& ret = count();
//
//	return 0;
//}


//引用的底层实现是指针


//总结一下:引用好指针的不同点:
//1.引用概念上定义一个变量的别名,指针存储一个变量的地址
//2.引用在定义时必须初始化,指针没有要求
//3.引用在初始化时引用一个实体后,就不能再引用其他实体,而指针可以在任何时候
//    指向任何一个同类型实体
//4.没有NULL引用,但又NULL指针
//5.在sizeof中含义不同:引用结果为引用类型的大小,但指针始终是'地址空间所占字节个数'  4/8
//6.引用自加,即引用的实体加1.  指针自加,即指针向后偏移一个类型的大小
//7.有多级指针,但是没有多级引用
//8.访问实体方式不同 : 指针需要显式解引用, 引用是编译器自己处理
//9.引用比之后做呢使用起来相对更安全


////二.auto   --  自动识别类型  --  可以少写那些很长很长的类型
////C++11 小语法
//int main()
//{
//	int a = 10;
//	//根据a的类型,推导b的类型
//	auto b = a;
//
//	return 0;
//}


//三.范围for遍历
int main()
{
	int array[] = { 1,2,3,4,5 };
	for (int i = 0; i < sizeof(array) / sizeof(array[0]); i++)
		cout << array[i] << "  ";
	cout << endl;

	
	//范围for遍历
	//依次取array中数据赋值给e 自动判断结束,自动迭代

	for (auto e : array)   //这个e可以是任何变量,x,y啥的都可以
	{
		cout << e << "  ";
	}
	cout << endl;

	return 0;
}
